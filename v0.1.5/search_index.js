var documenterSearchIndex = {"docs":
[{"location":"deps/solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"deps/solutions/#GeometricSolutions.EnsembleSolution","page":"Solutions","title":"GeometricSolutions.EnsembleSolution","text":"EnsembleSolution: Collection of solutions for an ensemble of geometric differential equations\n\nContains all fields necessary to store the solutions of an EnsembleProblem, which represents multiple instances of a geometric differential equation with different initial conditions and/or parameters. Each solution in the ensemble is stored as a GeometricSolution.\n\nFields\n\nt: common time series shared across all solutions in the ensemble\ns: vector of GeometricSolution objects, one for each problem instance\nproblem: the original EnsembleProblem\n\nType Parameters\n\ndType: data type for solution values (e.g., Float64)\ntType: data type for time values (e.g., Float64)\nsType: type of the solution vector\nprobType: type of the ensemble problem\n\nConstructor\n\nEnsembleSolution(problem::EnsembleProblem, step::Int = 1)\n\nCreates an EnsembleSolution from an EnsembleProblem. The optional parameter step determines the intervals for storing each solution, i.e., if step > 1 only every step'th solution point is stored for each ensemble member.\n\nUsage\n\nAn EnsembleSolution can be iterated over to access individual solutions:\n\nfor sol in ensemble_solution\n    # sol is a GeometricSolution\n    process_solution(sol)\nend\n\nIndividual solutions can be accessed by index:\n\nfirst_solution = ensemble_solution[1]\nlast_solution = ensemble_solution[end]\n\nThe number of solutions in the ensemble:\n\nn_solutions = nsamples(ensemble_solution)\n\nConvert all solutions to arrays for analysis:\n\nsolution_arrays = arrays(ensemble_solution)\n\nSee Also\n\nGeometricSolution: Individual solution type\nEnsembleProblem: Ensemble problem type\narrays: Convert solutions to arrays for analysis\nrelative_maximum_error: Compare ensemble solutions\n\n\n\n\n\n","category":"type"},{"location":"deps/solutions/#GeometricSolutions.GeometricSolution","page":"Solutions","title":"GeometricSolutions.GeometricSolution","text":"GeometricSolution: Solution of a geometric differential equation\n\nContains all fields necessary to store the solution of a GeometricProblem.\n\nFields\n\nt:  time steps\ns:  NamedTuple of DataSeries for each solution component\nstep: store every step'th time step (default: 1)\nnstore: number of time steps to store\noffset: offset of current time step\n\nConstructors\n\nGeometricSolution(problem, step = 1)\n\nThe usual way to initialise a Solution is by passing a GeometricEquations.EquationProblem, which can for example be an GeometricEquations.ODEProblem or GeometricEquations.PODEProblem. The optional parameter step determines the intervals for storing the solution, i.e., if step > 1 only every step'th solution is actually stored.\n\n\n\n\n\n","category":"type"},{"location":"deps/solutions/#GeometricSolutions.arrays-Tuple{EnsembleSolution}","page":"Solutions","title":"GeometricSolutions.arrays","text":"Convert solutions to arrays for analysis\n\n\n\n\n\n","category":"method"},{"location":"deps/solutions/#GeometricSolutions.relative_maximum_error-Tuple{EnsembleSolution, EnsembleSolution}","page":"Solutions","title":"GeometricSolutions.relative_maximum_error","text":"Compute the relative maximum error between two ensemble solutions.\n\n\n\n\n\n","category":"method"},{"location":"deps/equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"deps/equations/","page":"Equations","title":"Equations","text":"The following data structures are all implemented in GeometricEquations.jl.","category":"page"},{"location":"deps/equations/#GeometricEquations.GeometricEquation","page":"Equations","title":"GeometricEquations.GeometricEquation","text":"GeometricEquation{invType,parType,perType} is the abstract type all equation types are derived from.\n\nAll equations should have fields for defining invariants, parameters and periodicity of the main state variable. The types of these fields are stored in the following type parameters:\n\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nThe Optional* types are all unions of the respective Null* types and NamedTuple or AbstractArray, i.e.,\n\nconst OptionalInvariants = Union{NamedTuple, NullInvariants}\nconst OptionalParameters = Union{NamedTuple, NullParameters}\nconst OptionalPeriodicity = Union{AbstractArray, NullPeriodicity}\n\nThe Null* types are empty structs, merely used for dispatch and the traits hasinvariants, hasparameters and hasperiodicity.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#Ordinary-Differential-Equations","page":"Equations","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"deps/equations/#GeometricEquations.ODE","page":"Equations","title":"GeometricEquations.ODE","text":"ODE: Ordinary Differential Equation\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nParameters\n\nvType <: Callable: type of v\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nODE(v, invariants, parameters, periodicity)\nODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.PODE","page":"Equations","title":"GeometricEquations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPODE(v, f, invariants, parameters, periodicity)\nPODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.HODE","page":"Equations","title":"GeometricEquations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHODE(v, f, hamiltonian, invariants, parameters, periodicity)\nHODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.IODE","page":"Equations","title":"GeometricEquations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\ngType <: Callable: type of g\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (tqv) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere\n\n_iode_default_v̄(v, t, q, params) = nothing\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.LODE","page":"Equations","title":"GeometricEquations.LODE","text":"LODE: Lagrangian Ordinary Differential Equation\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)\nLODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere\n\n_lode_default_v̄(v, t, q, params) = nothing\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.SODE","page":"Equations","title":"GeometricEquations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nThe dynamical variables q with initial condition q_0 take values in mathbbR^d.\n\nParameters\n\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields for each substep\nq: tuple of functions computing the solutions for each substep\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSODE(v, invariants, parameters, periodicity)\nSODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\nSODE(v, q, invariants, parameters, periodicity)\nSODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#Differential-Algebraic-Equations","page":"Equations","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"deps/equations/#GeometricEquations.DAE","page":"Equations","title":"GeometricEquations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nuType <: Callable: type of u\nϕType <: Callable: type of ϕ\nūType <: OptionalCallable: type of ū\nψType <: OptionalCallable: type of ψ\nv̄Type <: Callable: type of v̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v(v, t, q, params)\nu: function computing the projection u(u, t, q, λ, params)\nϕ: algebraic constraint ϕ(ϕ, t, q, params)\nū: function computing the secondary projection field ū(ū, t, q, λ, params) (optional)\nψ: secondary constraint ψ(ψ, t, q, v, params) (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)\nDAE(v, u, ϕ, ū, ψ; kwargs...)\nDAE(v, u, ϕ; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nThe DAE is created by\n\nequ = DAE(v, u, ϕ)\n\nor\n\nequ = DAE(v, u, ϕ, ū, ψ)\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.PDAE","page":"Equations","title":"GeometricEquations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)\nPDAE(v, f, u, g, ϕ; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe PDAE is created by\n\nequ = PDAE(v, f, u, g, ϕ)\n\nor\n\nequ = PDAE(v, f, u, g, ϕ, ū, ḡ, ψ)\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.HDAE","page":"Equations","title":"GeometricEquations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)\nHDAE(v, f, u, g, ϕ, h; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g, ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe HDAE is created by\n\nequ = HDAE(v, f, u, g, ϕ, h)\n\nor\n\nequ = HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h)\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.IDAE","page":"Equations","title":"GeometricEquations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nIDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere\n\n_idae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.LDAE","page":"Equations","title":"GeometricEquations.LDAE","text":"LDAE: Lagrangian Differential Algebraic Equation\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nωType <: Callable: type of ω\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nlagType <: Callable: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (tq)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (tq) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (tq) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nLDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere\n\n_ldae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#Stochastic-Differential-Equations","page":"Equations","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"deps/equations/#GeometricEquations.SDE","page":"Equations","title":"GeometricEquations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nBType <: Callable: type of B\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSDE(v, B, invariants, parameters, periodicity)\nSDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.PSDE","page":"Equations","title":"GeometricEquations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nBType <: Callable: type of B\nGType <: Callable: type of G\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPSDE(v, f, B, G, invariants, parameters, periodicity)\nPSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#GeometricEquations.SPSDE","page":"Equations","title":"GeometricEquations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)\nSPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"deps/equations/#Discrete-Equations","page":"Equations","title":"Discrete Equations","text":"","category":"section"},{"location":"deps/equations/#GeometricEquations.DELE","page":"Equations","title":"GeometricEquations.DELE","text":"DELE: Discrete Euler-Lagrange Equation\n\nDiscrete Euler-Lagrange equations define an initial value problem of the form\n\nD_1 L_d (q_n q_n+1) + D_2 L_d (q_n-1 q_n) = 0 \n\nwith discrete Lagrangian L_d.\n\nParameters\n\nLdType <: Callable: type of Ld\nD1LdType <: Callable: type of D1Ld\nD2LdType <: Callable: type of D2Ld\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nLd: function computing the discrete Lagrangian\nD1Ld: function computing the derivative of the discrete Lagrangian w.r.t. the first argument\nD2Ld: function computing the derivative of the discrete Lagrangian w.r.t. the second argument\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDELE(Ld, D1Ld, D2Ld, invariants, parameters, periodicity)\nDELE(Ld, D1Ld, D2Ld; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function Ld providing the discrete Lagrangian must have the interface\n\nfunction Ld(t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    return ...\nend\n\nwhere t_{n} and t_{n+1} are the time of the previous and next step, q_{n} and q_{n+1} are the solution vectors of the previous and next step, and params is a NamedTuple of additional parameters on which the Lagrangian may depend. The derivatives of the discrete Lagrangian with respect to its first and second argument, D_1 L_d and D_2 L_d, respectively, must have the interfaces\n\nfunction D1Ld(D, t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    D1[1] = ...\n    D1[2] = ...\n    ...\nend\n\nand\n\nfunction D2Ld(D2, t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    D2[1] = ...\n    D2[2] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#Problem-Types","page":"Problems","title":"Problem Types","text":"","category":"section"},{"location":"deps/problems/","page":"Problems","title":"Problems","text":"The following data structures are all implemented in GeometricEquations.jl. Each problem type is derived from EquationProblem.","category":"page"},{"location":"deps/problems/#Geometric-Equation-Problems","page":"Problems","title":"Geometric Equation Problems","text":"","category":"section"},{"location":"deps/problems/#GeometricEquations.GeometricProblem","page":"Problems","title":"GeometricEquations.GeometricProblem","text":"Abstract type that describes a generic interface for different problem types.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.EquationProblem","page":"Problems","title":"GeometricEquations.EquationProblem","text":"EquationProblem: stores a GeometricEquation together with initial conditions, parameters, time span and time step size.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nfunctionsType <: NamedTuple: types of all function methods\nsolutionsType <: NamedTuple: types of all solution methods\nicsType <: NamedTuple: types of all initial conditions\nparType <: OptionalParameters: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\nfunctions: methods for all vector fields, etc., that define the problem\nsolutions: methods for all solutions, etc., if defined\ntimespan: time span for problem (t₀,t₁)\ntimestep: time step to be used in simulation\nics: NamedTuple containing the initial conditions, must contain one field for each state variable\nparameters: either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nSubtypes\n\nThe EquationProblem type has various subtypes for the different equations types, that are defined e.g. via\n\nconst ODEProblem = EquationProblem{ODE}\n\nand provide convenience constructors to construct an equation and the corresponding problem in one step, e.g.,\n\nODEProblem(v, timespan, timestep, ics::NamedTuple; kwargs...)\nODEProblem(v, timespan, timestep, q₀::StateVariable; kwargs...)\n\nAll problem subtypes take the following keyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nIf not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are\n\nfunctions for invariants,\narbitrary data structures for parameters,\nthe same data structure as the solution for periodicity.\n\nThe latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.EnsembleProblem","page":"Problems","title":"GeometricEquations.EnsembleProblem","text":"EnsembleProblem: stores a GeometricEquation together with multiple sets of initial conditions and/or parameters, a time span for integration and a time step size.\n\nAn EnsembleProblem is initialized by providing a GeometricEquation, an integration time span (typically a tuple with two values, start and end time, respectively), a timestep, and one of the three following options:\n\na vector of initial conditions and a vector of parameter sets, with both vectors having the same length,\na vector of initial conditions and a single set of parameters,\na single initial condition and a vector of parameter sets.\n\nEach initial condition is a NamedTuple that contains one field for each state variable. Each parameter set is either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters.\n\nThe different constructors then generate two vectors, one for the initial conditions and one for the parameters, where each pair of the corresponding entries defines one problem. In the first case, the respective constructor just checks if both vectors are of the same size. In the second case, the respective constructor creates a parameter vector, where each entry holds the same parameter set. In the third case, the respective constructor creates an initial condition vector, where each entry holds the same initial conditions. One may be inclined to think that the first and second constructor lead to a waste of memory, but in reality the respective vectors only hold references to the same initial conditons or parameters. Thus the data is not actually duplicated.\n\nEach pair of initial conditions and parameters is referred to as sample. The methods\n\nlength(::EnsembleProblem)\nnsamples(::EnsembleProblem)\n\nreturn the number of samples in a EnsembleProblem. A single initial condition or parameter set can be retrieved by the methods\n\ninitial_condition(::EnsembleProblem, i)\nparameter(::EnsembleProblem, i)\n\nwhere i is the index of the sample. Typically, however, e.g. when integrating all samples of an EnsembleProblem with GeometricIntegrators, it is more convenient to retrieve the corresponding GeometricProblem via the method\n\nproblem(::EnsembleProblem, i)\n\nThe EnsembleProblem also allows to iterate over all samples, e.g.\n\nfor problem in ensemble\n    # ...\n    # integrate problem\n    # ...\nend\n\nwhere ensemble is an EnsembleProblem and problem is the corresponding GeometricProblem.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nfunctionsType <: NamedTuple: types of all function methods\nsolutionsType <: NamedTuple: types of all solution methods\nicsType <: AbstractVector{<:NamedTuple}: types of all initial conditions\nparType <: AbstractVector{<:OptionalParameters}: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\nfunctions: methods for all vector fields, etc., that define the problem\nsolutions: methods for all solutions, etc., if defined\ntimespan: time span for problem (t₀,t₁)\ntimestep: time step to be used in simulation\nics: vector of NamedTuple containing the initial conditions, each NamedTuple must contain one field for each state variable\nparameters: vector of either NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nConstructors\n\nThe EnsembleProblem provides the following constructors:\n\nEnsembleProblem(equ, timespan, timestep, ics::AbstractVector{<:NamedTuple}, parameters::AbstractVector{<:OptionalParameters})\nEnsembleProblem(equ, timespan, timestep, ics::AbstractVector{<:NamedTuple}, parameters::OptionalParameters=NullParameters())\nEnsembleProblem(equ, timespan, timestep, ics::NamedTuple, parameters::AbstractVector{<:OptionalParameters})\nEnsembleProblem(equ, timespan, timestep, ics, ::Nothing) =\n    EnsembleProblem(equ, timespan, timestep, ics, NullParameters())\nEnsembleProblem(equ, timespan, timestep, ics; parameters = NullParameters()) =\n    EnsembleProblem(equ, timespan, timestep, ics, parameters)\n\nequ is a subtype of GeometricEquation\ntimespan is a tuple (t₀,t₁) of the integration time span with t₀ the start time and t₁ the end time\ntimestep is the time step, typically a value of some AbstractFloat subtype\nics are the initial conditions, either a single set or a vector of multiple sets\nparameters are the static parameters of the problem, either a single set or a vector of multiple sets\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#Ordinary-Differential-Equations","page":"Problems","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"deps/problems/#GeometricEquations.ODEProblem","page":"Problems","title":"GeometricEquations.ODEProblem","text":"ODEProblem: Ordinary Differential Equation Problem\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nThe dynamical variables q with initial condition q_0 take values in mathbbR^d.\n\nConstructors\n\nODEProblem(v, timespan, timestep, ics::NamedTuple; kwargs...)\nODEProblem(v, timespan, timestep, q₀::StateVariable; kwargs...)\nODEProblem(v, timespan, timestep, q₀::AbstractArray; kwargs...)\n\nwhere v is the function computing the vector field, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entry q of type StateVariable. The initial condition q₀ can also be prescribed directly, as a StateVariable or an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.PODEProblem","page":"Problems","title":"GeometricEquations.PODEProblem","text":"PODEProblem: Partitioned Ordinary Differential Equation Problem\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d.\n\nConstructors\n\nPODEProblem(v, f, timespan, timestep, ics; kwargs...)\nPODEProblem(v, f, timespan, timestep, q₀::StateVariable, p₀::StateVariable; kwargs...)\nPODEProblem(v, f, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray; kwargs...)\n\nwhere v and f are the function computing the vector fields, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v and f see PODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.HODEProblem","page":"Problems","title":"GeometricEquations.HODEProblem","text":"HODEProblem: Hamiltonian Ordinary Differential Equation Problem\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nConstructors\n\nHODEProblem(v, f, hamiltonian, timespan, timestep, ics; kwargs...)\nHODEProblem(v, f, hamiltonian, timespan, timestep, q₀::StateVariable, p₀::StateVariable; kwargs...)\nHODEProblem(v, f, hamiltonian, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray; kwargs...)\n\nwhere v and f are the function computing the vector fields, hamiltonian returns the value of the Hamiltonian (i.e. the total energy), timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f and hamiltonian see HODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.IODEProblem","page":"Problems","title":"GeometricEquations.IODEProblem","text":"IODEProblem: Implicit Ordinary Differential Equation Problem\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variable v with initial condition v(t_0) = v_0 takes values in mathbbR^d.\n\nConstructors\n\nIODEProblem(ϑ, f, timespan, timestep, ics; kwargs...)\nIODEProblem(ϑ, f, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::AlgebraicVariable; kwargs...)\nIODEProblem(ϑ, f, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray, λ₀::AbstractArray = zero(q₀); kwargs...)\nIODEProblem(ϑ, f, g, timespan, timestep, ics; kwargs...)\nIODEProblem(ϑ, f, g, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::AlgebraicVariable; kwargs...)\nIODEProblem(ϑ, f, g, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray, λ₀::AbstractArray = zero(q₀); kwargs...)\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f and g see IODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _iode_default_v̄ and f̄ = f.\n\nInitial conditions have to be prescribed for (q,p). If instead initial conditions are available only for (q,v), the function ϑ can be called to compute the corresponding initial value of p.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.LODEProblem","page":"Problems","title":"GeometricEquations.LODEProblem","text":"LODEProblem: Lagrangian Ordinary Differential Equation Problem\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d. The algebraic variable λ with initial condition λ(t_0) = λ_0 takes values in mathbbR^m.\n\nConstructors\n\nLODEProblem(ϑ, f, ω, l, timespan, timestep, ics; kwargs...)\nLODEProblem(ϑ, f, ω, l, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::AlgebraicVariable; kwargs...)\nLODEProblem(ϑ, f, ω, l, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray, λ₀::AbstractArray = zero(q₀); kwargs...)\nLODEProblem(ϑ, f, g, ω, l, timespan, timestep, ics; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::AlgebraicVariable; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, timespan, timestep, q₀::AbstractArray, p₀::AbstractArray, λ₀::AbstractArray = zero(q₀); kwargs...)\n\nwhere ϑ, f and g are the functions computing the momentum and the vector fields, respectively, ω determines the symplectic matrix, and l returns the Lagrangian, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}, where λ₀ can also be omitted. For the interfaces of the functions ϑ, f, g, ω and l see LODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _lode_default_v̄ and f̄ = f.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.SODEProblem","page":"Problems","title":"GeometricEquations.SODEProblem","text":"SODEProblem: Split Ordinary Differential Equation Problem\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nThe dynamical variables q with initial condition q_0 take values in mathbbR^d.\n\nConstructors\n\nSODEProblem(v, q, timespan, timestep, ics::NamedTuple; kwargs...)\nSODEProblem(v, q, timespan, timestep, q₀::StateVariable; kwargs...)\nSODEProblem(v, q, timespan, timestep, q₀::AbstractArray; kwargs...)\nSODEProblem(v, timespan, timestep, ics::NamedTuple; kwargs...)\nSODEProblem(v, timespan, timestep, q₀::StateVariable; kwargs...)\nSODEProblem(v, timespan, timestep, q₀::AbstractArray; kwargs...)\n\nwhere v is a tuple of functions computing the vector fields for each substep, q is an optional tuple of functions computing the solution for each substep, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#Differential-Algebraic-Equations","page":"Problems","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"deps/problems/#GeometricEquations.DAEProblem","page":"Problems","title":"GeometricEquations.DAEProblem","text":"DAEProblem: Differential Algebraic Equation Problem\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nThe dynamical variable q with initial conditions q(t_0) = q_0 takes values in mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nDAEProblem(v, u, ϕ, ū, ψ, timespan, timestep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, ū, ψ, timespan, timestep, q₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nDAEProblem(v, u, ϕ, timespan, timestep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, timespan, timestep, q₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, λ and μ. The initial conditions q₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, u, ϕ, ū, ψ see DAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a DAEProblem accepts a function v̄ for the computation of an initial guess for the vector field with default value v̄ = v.\n\nFunction Definitions\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the DAEProblem can be created by\n\ntimespan = (0.0, 1.0)\ntimestep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = DAEProblem(v, u, ϕ, timespan, timestep, q₀, λ₀)\n\nor\n\nprob = DAEProblem(v, u, ϕ, ū, ψ, timespan, timestep, q₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.PDAEProblem","page":"Problems","title":"GeometricEquations.PDAEProblem","text":"PDAEProblem: Partitioned Differential Algebraic Equation Problem\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, timespan, timestep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nPDAEProblem(v, f, u, g, ϕ, timespan, timestep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ see PDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a PDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the PDAEProblem can be created by\n\ntimespan = (0.0, 1.0)\ntimestep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = PDAEProblem(v, f, u, g, ϕ, timespan, timestep, q₀, p₀, λ₀)\n\nor\n\nprob = PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, timespan, timestep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.HDAEProblem","page":"Problems","title":"GeometricEquations.HDAEProblem","text":"HDAEProblem: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, timespan, timestep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, timespan, timestep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ, and h see HDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a HDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g, ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the HDAEProblem can be created by\n\ntimespan = (0.0, 1.0)\ntimestep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, timespan, timestep, q₀, p₀, λ₀)\n\nor\n\nprob = HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, timespan, timestep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.IDAEProblem","page":"Problems","title":"GeometricEquations.IDAEProblem","text":"IDAEProblem: Implicit Differential Algebraic Equation Problem\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, timespan, timestep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, timespan, timestep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ see IDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _idae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.LDAEProblem","page":"Problems","title":"GeometricEquations.LDAEProblem","text":"LDAEProblem: Lagrangian Differential Algebraic Equation Problem\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, timespan, timestep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, timespan, timestep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, timespan, timestep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntimespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω and l see LDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _ldae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the LDAEProblem can be created by\n\ntimespan = (0.0, 1.0)\ntimestep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ω, l, timespan, timestep, q₀, p₀, λ₀)\n\nor\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, timespan, timestep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#Stochastic-Differential-Equations","page":"Problems","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"deps/problems/#GeometricEquations.SDEProblem","page":"Problems","title":"GeometricEquations.SDEProblem","text":"SDEProblem: Stratonovich Stochastic Differential Equation Problem\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSDEProblem(v, B, timespan, timestep, ics::NamedTuple; kwargs...)\nSDEProblem(v, B, timespan, timestep, q₀::StateVariable; kwargs...)\n\nwhere v is the function computing the vector field and B computes the diffusion matrix timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.PSDEProblem","page":"Problems","title":"GeometricEquations.PSDEProblem","text":"PSDEProblem: Stratonovich Partitioned Stochastic Differential Equation Problem\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nPSDEProblem(v, f, B, G, timespan, timestep, ics::NamedTuple; kwargs...)\nPSDEProblem(v, f, B, G, timespan, timestep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and B and G compute the diffusion matrices, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#GeometricEquations.SPSDEProblem","page":"Problems","title":"GeometricEquations.SPSDEProblem","text":"SPSDEProblem: Stratonovich Split Partitioned Stochastic Differential Equation Problem\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSPSDEProblem(v, f1, f2, B, G1, G2, timespan, timestep, ics::NamedTuple; kwargs...)\nSPSDEProblem(v, f1, f2, B, G1, G2, timespan, timestep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and Bᵢ and Gᵢ compute the diffusion matrices, timespan is the time interval (t₀,t₁) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"deps/problems/#Discrete-Equations","page":"Problems","title":"Discrete Equations","text":"","category":"section"},{"location":"deps/problems/#GeometricEquations.DELEProblem","page":"Problems","title":"GeometricEquations.DELEProblem","text":"DELEProblem: Discrete Euler-Lagrange Equation Problem\n\nDiscrete Euler-Lagrange equations define an initial value problem of the form\n\nD_1 L_d (q_n q_n+1) + D_2 L_d (q_n-1 q_n) = 0 \n\nwith discrete Lagrangian L_d.\n\nThe dynamical variables q with initial conditions q_0 and q_1 take values in mathbbR^d.\n\nConstructors\n\nDELEProblem(Ld, D1Ld, D2Ld, timespan, timestep, ics::NamedTuple; kwargs...)\nDELEProblem(Ld, D1Ld, D2Ld, timespan, timestep, q₀::StateVariable, q₁::StateVariable; kwargs...)\nDELEProblem(Ld, D1Ld, D2Ld, timespan, timestep, q₀::AbstractArray, q₁::AbstractArray; kwargs...)\n\nwhere Ld is the function computing the discrete Lagrangian, D1Ld and D2Ld are functions computing the derivative of Ld with respect to the first and second argument, timespan is the time interval (t₀,tₙ) for the problem to be solved in, timestep is the time step to be used in the simulation, and ics is a NamedTuple with entries q₀ and  q₁ of type StateVariable. The initial conditions q₀ and  q₁ can also be prescribed directly, as a StateVariable or an AbstractArray{<:Number}.\n\nFor the interface of the functions Ld, D1Ld and D2Ld see DELE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe function Ld providing the discrete Lagrangian must have the interface\n\nfunction Ld(t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    return ...\nend\n\nwhere t_{n} and t_{n+1} are the time of the previous and next step, q_{n} and q_{n+1} are the solution vectors of the previous and next step, and params is a NamedTuple of additional parameters on which the Lagrangian may depend. The derivatives of the discrete Lagrangian with respect to its first and second argument, D_1 L_d and D_2 L_d, respectively, must have the interfaces\n\nfunction D1Ld(D, t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    D1[1] = ...\n    D1[2] = ...\n    ...\nend\n\nand\n\nfunction D2Ld(D2, t_{n}, t_{n+1}, q_{n}, q_{n+1}, params)\n    D2[1] = ...\n    D2[2] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"euler/#Euler-Integrators","page":"Euler Methods","title":"Euler Integrators","text":"","category":"section"},{"location":"euler/#GeometricIntegratorsBase.ExplicitEuler","page":"Euler Methods","title":"GeometricIntegratorsBase.ExplicitEuler","text":"Explicit Euler Method.\n\n\n\n\n\n","category":"type"},{"location":"euler/#GeometricIntegratorsBase.ExplicitEulerCache","page":"Euler Methods","title":"GeometricIntegratorsBase.ExplicitEulerCache","text":"Explicit Euler integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"euler/#GeometricIntegratorsBase.ImplicitEuler","page":"Euler Methods","title":"GeometricIntegratorsBase.ImplicitEuler","text":"Implicit Euler Method.\n\n\n\n\n\n","category":"type"},{"location":"euler/#GeometricIntegratorsBase.ImplicitEulerCache","page":"Euler Methods","title":"GeometricIntegratorsBase.ImplicitEulerCache","text":"Implicit Euler integrator cache.\n\n\n\n\n\n","category":"type"},{"location":"#GeometricIntegratorsBase","page":"Home","title":"GeometricIntegratorsBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeometricIntegratorsBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"extrapolation/#Extrapolation-Methods","page":"Extrapolation Methods","title":"Extrapolation Methods","text":"","category":"section"},{"location":"extrapolation/","page":"Extrapolation Methods","title":"Extrapolation Methods","text":"The extrapolation routines are exclusively used for computing initial guesses and are usually not called directly by the user.","category":"page"},{"location":"extrapolation/#GeometricIntegratorsBase.aitken_neville!-Union{Tuple{TT}, Tuple{AbstractArray, TT, AbstractVector{TT}, AbstractVector}} where TT","page":"Extrapolation Methods","title":"GeometricIntegratorsBase.aitken_neville!","text":"Compute p(x) where p is the unique polynomial of degree length(xi), such that p(x[i]) = y[i]) for all i. Call with\n\naitken_neville!(x::AbstractVector, t::Real, ti::AbstractVector, xi::AbstractMatrix)\n\nwhere\n\nx:  evaluation value\nt:  evaluation point\nti: interpolation nodes\nxi: interpolation values\n\n\n\n\n\n","category":"method"},{"location":"extrapolation/#GeometricIntegratorsBase.EulerExtrapolation","page":"Extrapolation Methods","title":"GeometricIntegratorsBase.EulerExtrapolation","text":"Euler extrapolation method with arbitrary order p.\n\nSolves the ordinary differential equation\n\nbeginaligned\ndotx = v(t x)  \nx(t_0) = x_0 \nendaligned\n\nfor x_1 = x(t_1), and is called with\n\nextrapolate!(t₀, x₀, t₁, x₁, problem, EulerExtrapolation(s))\n\nwhere\n\nt₀: initial time\nt₁: final   time\nx₀: initial value x_0 = x(t_0)\nx₁: final   value x_1 = x(t_1)\nproblem: ODEProblem whose solution to extrapolate\ns:  number of interpolations (order p=s+1)\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#GeometricIntegratorsBase.HermiteExtrapolation","page":"Extrapolation Methods","title":"GeometricIntegratorsBase.HermiteExtrapolation","text":"Hermite's Interpolating Polynomials\n\nImplements a two point Hermite inter-/extrapolation function which passes through the function and its first derivative for the interval 01. The polynomial is determined by four constraint equations, matching the function and its derivative at the points 0 and 1.\n\nCall with one of the following methods\n\nextrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, HermiteExtrapolation())\nextrapolate!(t₀, x₀, ẋ₀, t₁, x₁, ẋ₁, t, x, ẋ, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, v, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, v, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, problem, HermiteExtrapolation())\nextrapolate!(t₀, x₀, t₁, x₁, t, x, ẋ, problem, HermiteExtrapolation())\n\nwhere\n\nt₀: first  sample time t_0\nx₀: first  solution value x_0 = x(t_0)\nẋ₀: first  vector field value ẋ_0 = v(t_0 x(t_0))\nt₁: second sample time t_1\nx₁: second solution value x_1 = x(t_1)\nẋ₁: second vector field value ẋ_1 = v(t_1 x(t_1))\nt:  time t to extrapolate\nx:  extrapolated solution value x(t)\nẋ:  extrapolated vector field value ẋ(t)\nv:  function to compute vector field with signature v(ẋ,t,x)\nproblem: ODEProblem whose vector field to use\n\nDerivation\n\nThe interpolation works as follows: Start by defining the 3rd degree polynomial and its derivative by\n\nbeginaligned\ng(x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3  \ng(x) = a_1 + 2 a_2 x + 3 a_3 x^2 \nendaligned\n\nand apply the constraints\n\nbeginaligned\ng(0) = f_0   Rightarrow  a_0 = f_0  \ng(1) = f_1   Rightarrow  a_0 + a_1 + a_2 + a_3 = f_1  \ng(0) = f_0   Rightarrow  a_1 = f_0  \ng(1) = f_1   Rightarrow  a_1 + 2 a_2 + 3 a_3 = f_1  \nendaligned\n\nSolving for a_0 a_1 a_2 a_3 leads to\n\nbeginaligned\na_0 = f_0  \na_1 = f_0  \na_2 = - 3 f_0 + 3 f_1 - 2 f_0 - f_1  \na_3 = 2 f_0 - 2 f_1 + f_0 + f_1 \nendaligned\n\nso that the polynomial g(x) reads\n\ng(x) = f_0 + f_0 x + (- 3 f_0 + 3 f_1 - 2 f_0 - f_1) x^2 + (2 f_0 - 2 f_1 + f_0 + f_1) x^3 \n\nThe function and derivative values can be factored out, so that g(x) can be rewritten as\n\ng(x) = f_0 (1 - 3 x^2 + 2 x^3) + f_1 (3 x^2 - 2 x^3) + f_0 (x - 2 x^2 + x^3) + f_1 (- x^2 + x^3) \n\nor in generic form as\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith basis functions\n\nbeginaligned\na_0 (x) = 1 - 3 x^2 + 2 x^3  \nb_0 (x) = x - 2 x^2 + x^3  \na_1 (x) = 3 x^2 - 2 x^3  \nb_1 (x) = - x^2 + x^3 \nendaligned\n\nThe derivative g(x) accordingly reads\n\ng(x) = f_0 a_0(x) + f_1 a_1(x) + f_0 b_0(x) + f_1 b_1(x) \n\nwith\n\nbeginaligned\na_0 (x) = - 6 x + 6 x^2  \nb_0 (x) = 1 - 4 x + 3 x^2  \na_1 (x) = 6 x - 6 x^2  \nb_1 (x) = - 2 x + 3 x^2 \nendaligned\n\nThe basis functions a_0and a_1 are associated with the function values at x_0 and x_1, respectively, while the basis functions b_0 and b_1 are associated with the derivative values at x_0 and x_1. The basis functions satisfy the following relations,\n\nbeginaligned\na_i (x_j) = delta_ij  \nb_i (x_j) = 0  \na_i (x_j) = 0  \nb_i (x_j) = delta_ij  \nij = 0 1 \nendaligned\n\nwhere delta_ij denotes the Kronecker-delta, so that\n\nbeginaligned\ng(0) = f_0  \ng(1) = f_1  \ng(0) = f_0  \ng(1) = f_1 \nendaligned\n\n\n\n\n\n","category":"type"},{"location":"extrapolation/#GeometricIntegratorsBase.MidpointExtrapolation","page":"Extrapolation Methods","title":"GeometricIntegratorsBase.MidpointExtrapolation","text":"Midpoint extrapolation method with arbitrary order p.\n\nFor an ODEProblem, this solves the ordinary differential equation\n\nbeginaligned\ndotx = v(t x)  \nx(t_0) = x_0 \nendaligned\n\nfor x_1 = x(t_1), and is called with\n\nextrapolate!(t₀, x₀, t₁, x₁, ::ODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nx₀: initial value x_0 = x(t_0)\nt₁: final   time\nx₁: final   value x_1 = x(t_1)\ns:  number of interpolations (order p=2s+2)\n\nFor a PODEProblem or HODEProblem, this solves the partitioned ordinary differential equation\n\nbeginaligned\ndotq = v(t q p)  \nq(t_0) = q_0  \ndotp = f(t q p)  \np(t_0) = p_0 \nendaligned\n\nfor q_1 = q(t_1) and p_1 = p(t_1)m and is called with\n\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::PODEProblem, MidpointExtrapolation(s))\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::HODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nq₀: initial position q_0 = q(t_0)\np₀: initial momentum p_0 = p(t_0)\nt₁: final   time\nq₁: final   position q_1 = q(t_1)\np₁: final   momentum p_1 = p(t_1)\ns:  number of interpolations (order p=2s+2)\n\nSimilarly, for a IODEProblem or LODEProblem, this solves the explicit dynamical equation\n\nbeginaligned\ndotq = v(t q)  \nq(t_0) = q_0  \ndotp = f(t q v)  \np(t_0) = p_0 \nendaligned\n\ncorresponding to the implicit problem, for q_1 = q(t_1) and p_1 = p(t_1), and is called with\n\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::IODEProblem, MidpointExtrapolation(s))\nextrapolate!(t₀, q₀, p₀, t₁, q₁, p₁, ::LODEProblem, MidpointExtrapolation(s))\n\nwhere\n\nt₀: initial time\nq₀: initial position q_0 = q(t_0)\np₀: initial momentum p_0 = p(t_0)\nt₁: final   time\nq₁: final   position q_1 = q(t_1)\np₁: final   momentum p_1 = p(t_1)\ns:  number of interpolations (order p=2s+2)\n\n\n\n\n\n","category":"type"}]
}
